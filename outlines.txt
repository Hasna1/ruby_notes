## key ruby concepts
* objects
  * methods (functions)
  * Everything has a value
* arithmetic operations
* string
* array
* hash
* symbols
* loops & iterators
* modules
* blocks, Proc
* regexps
* dynamic method definition
  * on classes
  * on instances
  * method_missing
* exceptions
  * rescue
  * ensure

## key rails concepts
* Exceptions and reading the logs
* MVC
* REST
* Migrations
* Routes
* Environments
* Scaffolding
* Generators-* ActiveRecord
  * Base WTF
  * find method
  * Associations
  * what's the SQL?
* Plugins
 * will_paginate

# Chris Pine's Learn To Program

1. Getting Started
2. Numbers
3. Letters
4. Variables and Assignment
5. Mixing It Up
6. More About Methods
7. Flow Control
8. Arrays and Iterators
9. Writing Your Own Methods
10. There's Nothing New to Learn in Chapter 10
11. IO
12. Classes
13. More Classes
14. Blocks and Procs
15. Beyond

# The Well-Grounded Rubyist by David Black

# Part 1: Ruby foundations

## Chapter 1. Bootstrapping your Ruby literacy
* Section 1.1. Basic Ruby language literacy
* Section 1.2. Anatomy of the Ruby installation
* Section 1.3. Ruby extensions and programming libraries
* Section 1.4. Out-of-the-box Ruby tools and applications
* Section 1.5. Summary

## Chapter 2. Objects, methods, and local variables
* Section 2.1. Talking to objects
* Section 2.2. Crafting an object: the behavior of a ticket
* Section 2.3. The innate behaviors of an object
* Section 2.4. A close look at method arguments
* Section 2.5. What you can’t do in argument lists
* Section 2.6. Local variables and variable assignment
* Section 2.7. Summary

## Chapter 3. Organizing objects with classes
* Section 3.1. Classes and instances
* Section 3.2. Instance variables and object state
* Section 3.3. Setter methods
* Section 3.4. Attributes and the attr_* method family
* Section 3.5. Inheritance and the Ruby class hierarchy
* Section 3.6. Classes as objects and message receivers
* Section 3.7. Constants up close
* Section 3.8. Nature vs. nurture in Ruby objects
* Section 3.9. Summary

## Chapter 4. Modules and program organization
* Section 4.1. Basics of module creation and use
* Section 4.2. Modules, classes, and method lookup
* Section 4.3. The method_missing method
* Section 4.4. Class/module design and naming
* Section 4.5. Summary

## Chapter 5. The default object (self), scope, and visibility
* Section 5.1. Understanding self, the current/default object
* Section 5.2. Determining scope
* Section 5.3. Deploying method-access rules
* Section 5.4. Writing and using top-level methods
* Section 5.5. Summary

## Chapter 6. Control-flow techniques
* Section 6.1. Conditional code execution
* Section 6.2. Repeating actions with loops
* Section 6.3. Iterators and code blocks
* Section 6.4. Error handling and exceptions
* Section 6.5. Summary

# Part 2: Built-in classes and modules

## Chapter 7. Built-in essentials
* Section 7.1. Ruby’s literal constructors
* Section 7.2. Recurrent syntactic sugar
* Section 7.3. Bang (!) methods and “danger”
* Section 7.4. Built-in and custom to_* (conversion) methods
* Section 7.5. Boolean states, boolean objects, and nil
* Section 7.6. Comparing two objects
* Section 7.7. Inspecting object capabilities
* Section 7.8. Summary

## Chapter 8. Strings, symbols, and other scalar objects
* Section 8.1. Working with strings
* Section 8.2. Symbols and their uses
* Section 8.3. Numerical objects
* Section 8.4. Times and dates
* Section 8.5. Summary

## Chapter 9. Collection and container objects
* Section 9.1. Arrays and hashes in comparison
* Section 9.2. Collection handling with arrays
* Section 9.3. Hashes
* Section 9.4. Ranges
* Section 9.5. Sets
* Section 9.6. Exploring the set.rb source code
* Section 9.7. Summary

## Chapter 10. Collections central: Enumerable and Enumerator
* Section 10.1. Gaining enumerability through each
* Section 10.2. Enumerable boolean queries
* Section 10.3. Enumerable searching and selecting
* Section 10.4. Element-wise enumerable operations
* Section 10.5. The relatives of each
* Section 10.6. The map method
* Section 10.7. Strings as quasi-enumerables
* Section 10.8. Sorting enumerables
* Section 10.9. Enumerators and the next dimension of enumerability
* Section 10.10. Enumerator semantics and uses
* Section 10.11. Enumerator method chaining
* Section 10.12. Summary

## Chapter 11. Regular expressions and regexp-based string operations
* Section 11.1. What are regular expressions?
* Section 11.2. Writing regular expressions
* Section 11.3. Building a pattern in a regular expression
* Section 11.4. Matching, substring captures, and MatchData
* Section 11.5. Fine-tuning regular expressions with quantifiers, anchors, and modifiers
* Section 11.6. Converting strings and regular expressions to each other
* Section 11.7. Common methods that use regular expressions
* Section 11.8. Summary

## Chapter 12. File, I/O, and system operations
* Section 12.1. How Ruby’s I/O system is put together
* Section 12.2. Basic file operations
* Section 12.3. Querying IO and File objects
* Section 12.4. Directory manipulation with the Dir class
* Section 12.5. File tools from the standard library
* Section 12.6. Summary

# Part 3: Ruby dynamics

## Chapter 13. Object individuation
* Section 13.1. Where the singleton methods are: the singleton class
* Section 13.2. Modifying Ruby’s core classes and modules
* Section 13.3. BasicObject as ancestor and class
* Section 13.4. Summary

## Chapter 14. Callable and runnable objects
* Section 14.1. Basic anonymous functions: the Proc class
* Section 14.2. Creating functions with lambda and ->
* Section 14.3. Methods as objects
* Section 14.4. The eval family of methods
* Section 14.5. Parallel execution with threads
* Section 14.6. Issuing system commands from inside Ruby programs
* Section 14.7. Summary

## Chapter 15. Callbacks, hooks, and runtime introspection
* Section 15.1. Callbacks and hooks
* Section 15.2. Interpreting object capability queries
* Section 15.3. Introspection of variables and constants
* Section 15.4. Tracing execution
* Section 15.5. Callbacks and method inspection in practice
* Section 15.6. Summary

